







Validation:
We transform and translate to the top-left corner the tetriminos in bit form.
0011        0110
0110    ->  1100



We have the bitarray
the strings of 8 bits represent our bitarray consisting of 4 longs:
00000000|00000000|00000000|00000000

Our current minimum board_size is 5.

For the sake of this visualisation let's deal with tetriminos of 8 bits:
-we have the S tetrimino (A)
A
0110
1100

B
1111
0000

=> 01101100

Let's try to fit the S tetrimino on the board.
We need to pad the short tetrimino to be as wide as the board_size

We split the short's "lines" into different parts, and pad the zeros in between.
//->We could shift everything to the left

the "lines" of the tetrimino are 0110 and 1100:          //, if we left shift them individually, they yield 1100 and 1000. We notice this cannot happen, because we lose one square.

01100 <- we need just one pad of zero between the lines
1100
=> 011001100

//Because the S tetrimino starts with the bit 0 we need to shift it away (to the left).
//0|11001100 (<< 1)
Board state is stored to the leftmost position of the bitarray consisting of longs.
00000|00000|00000|00000|00000|00000|00 The last two bits aren't used for this board_size.

00000
00000
00000
00000
00000|00

For the (empty) board above we try to fit the padded S tetrimino with and (&) operation in bitarrand:
01100110|0 &
00000000|00000000|00000000
The result is totally empty so the piece doesn't overlap with any square of another piece (a bit in the bitarray).
We then bitarrxor or bitarror the piece into its place (or use addition (+) operation, since the bits don't overlap), whichever is more performant.

The bitarray state after our operations:
01100110|00000000|00000000
The board state after our operations
01100
11000
00000
00000
00000

0110011000000000000000000

Then we attempt to place the I tetrimino (B):
1111
0000

11110
0000
We pad it to match the board_size and attempt to fit it on the board at increasing indices:
111100000
0110011000000000000000000 <-- The first attempt at placing at index 0

   111100000
0110011000000000000000000 <-- The second attempt at placing at index 3
    111100000
0110011000000000000000000 <-- The third attempt at placing at index 7
       111100000
01100110|00000000|000000000
       1|11100000

The first attempt:
Bitarray state:
11110000|0
01100110|00000000|000000000
Board state:
11110|0000
01100|11000|00000|00000|00000
We split the tetrimino across the border of the long.
In this attempt quickly noticed the pieces overlap.

The second attempt:
Board state:
   111|10000|0
01100|11000|00000|00000|00000
We need to detect the piece overrunning the border of the board.
Dividing the piece into board_size long "lines" as it is now that it is shifted,
 and then right shifting with the index of the attempt to make the least bits disappear.
After the right shift, shift back to left with the index to see if the piece changed (at least one bit disappeared).
VISUALISATION:
We get the index of the trial.
We use the index in shifting the "lines" of the tetrimino individually.
Redundancy check with left shift if bits disappeared. If they did disappear, we can jump the index to the next line.
11110|0000 We shift to the right by the index parameter:
01111|00000
00111|100000
00011|1100000 We left shift the answer back as many bits:
11000|0000 We notice bits are missing, we discontinue the attempt,
 and return the notice to caller function to jump to the next line.

The next check will happen on the next "line" of the board:
      11110|0000
01100|11000|00000|00000|00000
We check the bit at the index, it is 1 so we skip to the next index, until we find 0:
        111|10000|0
01100|11000|00000|00000|00000
We come back to the trial function with index 8:
11110|0000 We shift to the right by the index parameter (8):
01111|00000
00111|100000
00011|1100000
00001|11100000
00000|111100000
00000|0111100000
00000|00111100000
00000|000111100000 All of the bits after | are lost, so we only have this left:
00000
00000 We left shift the answer back as many bits:
00000 We notice bits are missing, we discontinue the attempt,


Let's go back to 16-bit tetriminoes and see what would happen with the T tetrimino (C):
C
1000
1100
1000
0000

Board_size is still 5, so we pad until 5:
(the pad function promotes the short 16-bit tetrimino type to unsinged long type of 64 bits)
10000
11000
10000
0000 <- the rest is zeroes, 0
Our binary numeral looks like this:
1000011000100000000
The board state is:
01100
11000
11110
00000
00000
In a string of bits we try to fit the tetrimino C at the top-left index, which happens to be 0:
10000|11000|10000|0000
01100|11000|11110|0000000000
We notice that the board has 0 in the front and we will test to see if the tetrimino fits:
bitarrand:
10000|11000|10000|0000 &
01100|11000|11110|0000000000
00000|11000|10000|0000 The piece overlaps with the squares of the pieces on the board.
We need to move to the next index (1).
We go to the trial function with the index 1 and shift all the "lines" by the index, 1, to the right
 and back to test if the piece can fit on the board at that index.
10000| >> 1 => 01000|0 << 1 => 10000|
11000| >> 1 => 01100|0 << 1 => 11000|
10000| >> 1 => 01000|0 << 1 => 10000|
0000-| >> 1 => 00000|0 << 1 => 00000|
No bits were lost in the redundancy check, so we move ahead to trial at the index 1.
 1000|01100|01000|00000 &
01100|11000|11110|0000000000
01000 01000 01000 0000 => again we notice overlapping since the result of bitwise AND, &, is not 0.
We continue this process until result in bitwise and is 0 OR until we determine it won't fit:
01100
11000
11110
x0000 <- the x is the index of trial
00000

1000011000100000000 the tetrimino C
011001100011110x000000000

We take the modulo of the index 15 against the board_size 5.
The result of 15 % 5 == 0. We right shift to test if bits are lost by the modulus 0 and back left.
We notice the piece stays intact.
Then we right shift the whole tetrimino C by the index 15 (1...f), and try to fit it on the board:

123456789abcdef1000011000100000000 the tetrimino C
011001100011110x000000000

12345|6789a|bcdef|10000|11000|100000000 the tetrimino C
01100|11000|11110|x0000|00000
We notice after redundancy checking the right shift of the tetrimino C that not every square fits on the board.
We pass the information to the caller to start the next board_size checking process.


We do redundancy checking whenever we right shift either:
- the lines of the padded (?) tetrimino individually (in trial function preprocessing)
- the whole padded tetrimino across the board's length (in trial function main task)

(The board state is irrelevant in this example:)
The padded tetrimino:
01100
11000
00000
0000

index modulus == 3
abc01|
10011|
00000|
0000

Let's concentrate on the last four bits on each "line" and create this numeral:
bc01|
0011|
0000|
000

Then we redundantly check by left shifting them back, if it still is a tetrimino.
0100|   -> it doesn't correspond to any known tetrimino short numeral
1100|   -> reuse the validation function here
0000|
000

We increase the index as much as we can, all the way until the next "line".

------------------------------
We wish to select the last 4 bits of each line.
We need to generate the following bitmask:
01111 01111 01111 01111
abc01|10011|00000|0000  & AND
00001 00011 00000 00000

00001 00011 00000 00000 ^ XOR
abc01|10011|00000|0000
00000 10000 00000 00000 Result is not zero, a bit was lost in translation.


BITMASKING:
0000 1111 => 0xF
                   1111 << (Left shift by the multiples of board_size.)
abc01 10011 00000 00000
Start from the greatest multiple of board size (5), in this case 3 => 15.
01111
abc01 10011 00000 00000 AND &
00001
abc01 10011 00000 00000 XOR ^
00000 == 0

      01111
abc01 10011 00000 00000 AND &
      00011
abc01 10011 00000 00000 XOR ^
      10000 != 0 --> piece doesn't fit!








board_size 2 and 3?







THE MAIN ISSUE HERE:
Can we translate the bit array into our textual solution?
We need to generate (after the solution has been found)
 the string of the solution with the correct alphabets.
We know:
-the size of the malloc we need to make by the board_size.
-the index for each tetrimino
We could know:
-the depth of the recursion (which gives us the alphabet in question)



solve(size_t depth)
solve(0)    alphabet[depth] == 'A'
 solve(1)    alphabet[depth] == 'B'
  solve(2)    alphabet[depth] == 'C'
   solve(3)    alphabet[depth] == 'D'























/*
The resulting padded tetrimino should be checked against the list of known tetriminoes
 after it has been left shifted and unpadded.
After bitmask bitwise AND &:
00001
00011
00000
00000
After left shift:
01000
11000
00000
00000
After unpadding the tetrimino we notice it is not any known tetrimino:
0100
1100
0000
0000
*/





//+11001|100 (<< 1)
// 00000|00000|00000|00000|00000|00000|00
//Here we should notice the tetrimino doesn't fit on the board. Because it is not properly splitted.

//11001
//100

A
0110
1100

B
1111
0000

C
0010
1110

-> 3 * 4 = 12
12 might fit into a board of 4 * 4 = 16


0AA0
AAC0
CCC0
BBBB
/*
0AA0
AA00
0000
0000

0AA0
AA00
BBBB
0000

If C was 1st and A 2nd, B won't fit into the square of 4
00C0
CCC0
0AA0
AA00


0AA0C
AACCC
BBBB0
00000
00000
*/



Board state:
00000
00000
00000
00000
00000
Tet
0110
1100







 